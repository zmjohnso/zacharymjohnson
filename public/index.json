[{"categories":null,"content":"About","date":"2025-03-29","objectID":"/about/","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Career I launched my professional career in February, 2021 at the software consultancy Atomic Object. While at Atomic I have worked on multiple projects with a variety of tech stacks, including React/Node and Angular/.NET Core projects. In addition to this site, my writings can be found on the Atomic Object blog, known as Spin. ","date":"2025-03-29","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Interests My technical interests include all things web development, Bitcoin and Austrian economics. When away from the computer I enjoy running and balance sports. ","date":"2025-03-29","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"I have always started my new web projects off with vanilla React, then added routing (react router), state management (zustand), etc., once I had the need for them. As the project would grow over time, more and more packages would need to be added. Eventually, you basically end up with your own custom framework. This is why the React team has started to recommend building new apps and websites with an existing React framework. Some currently supported production ready frameworks include Next.js, Remix and Gatsby. However, at the time of this writing, only Next.js supports all the latest React features, such as React Server Components (RSCs). Therefore, given the React teams recommendation to start new projects off with a framework, my own experience with building “custom” React frameworks and the ability to utilize cutting edge React features such as RSCs, I have started using Next.js for my new web apps. Here are a few challenges that I ran into, from the perspective of a React developer. ","date":"2024-11-20","objectID":"/nextjs-for-react-devs/:0:0","tags":["Next.js","React"],"title":"Next.js for React Devs","uri":"/nextjs-for-react-devs/"},{"categories":null,"content":"Everything is a Server Component By default, when creating a new component with Next.js, that component will be a server component. This means that the code in that server component will be rendered on the server. Therefore, any “reactive” code (such as useState, useEffect, etc.) cannot be used in the server component. If you want to use these hooks, you will need to create a new component and annotate it with the \"use client\" directive. Note: the sever component has no such annotation. All components are simply server components by default. This design encourages you to do the bulk of the rendering on the server, and thinking very carefully about what code needs to respond to user interaction, and which code is simply “static.” For example, here is the code for the Header component from lalisolari.com: import { FaInstagram } from \"@react-icons/all-files/fa/FaInstagram\"; import LanguageDropdown from \"./languageDropdown\"; import Logo from \"./logo\"; export default function Header() { return ( \u003cheader className=\"flex flex-col bg-transparent shadow-none py-2\"\u003e \u003cdiv className=\"flex justify-between items-center\"\u003e \u003cLogo /\u003e \u003cdiv className=\"flex flex-row pr-2 md:pr-4\"\u003e \u003cLanguageDropdown /\u003e \u003ca href=\"https://www.instagram.com/lalisolariart/\" target=\"_blank\" rel=\"noopener noreferrer\" \u003e \u003cbutton aria-label=\"instagram link button\" className=\"p-2 rounded-full bg-white text-gray-500 hover:bg-gray-100\" \u003e \u003cFaInstagram size={23} /\u003e \u003c/button\u003e \u003c/a\u003e \u003c/div\u003e \u003c/div\u003e \u003c/header\u003e ); } We can see that this is a server component that renders a logo, some static icons and buttons, and language dropdown component. That LanguageDropdown component makes use of React useState and useRef, therefore it needs to be a client component. Here is how the start of that code looks: \"use client\"; import { useState, useRef, useEffect, useTransition } from \"react\"; import { MdTranslate } from \"@react-icons/all-files/md/MdTranslate\"; import { usePathname, useRouter } from \"../navigation\"; import clsx from \"clsx\"; export default function LanguageDropdown() { const router = useRouter(); const [isPending, startTransition] = useTransition(); const pathname = usePathname(); const [isOpen, setIsOpen] = useState(false); const dropdownRef = useRef\u003cHTMLDivElement\u003e(null); .... Splitting the code in this manner allows for doing the maximum amount of server side rendering, therefore reducing the JavaScript bundle size sent to the client. See this link from the Next.js docs for a full list of the benefits of Server Rendering. Normally, React devs are accustomed to splitting up web pages into many different components (as opposed to one page one component). Next.js and server components now also introduce the idea of splitting the components up further into the sections that can be rendered on the server and those which respond to user action (on the client). ","date":"2024-11-20","objectID":"/nextjs-for-react-devs/:1:0","tags":["Next.js","React"],"title":"Next.js for React Devs","uri":"/nextjs-for-react-devs/"},{"categories":null,"content":"\u003cImage/\u003e vs \u003cimg/\u003e Another concept that I initially struggled with when switching to Next.js was the \u003cImage /\u003e component. In my vanilla React apps, I was used to doing the following: \u003cimg height=\"auto\" width=\"100%\" ... /\u003e With a wrapping grid component or similar, which determined the size of the images. However, this is not possible with the Next.js Image component, as the width and height are required values which must be integers (in pixels). This is done to prevent layout shift during loading, which is a common cause of a poor user experience. However, this behavior of requiring the width and height values can make the Image component quite unnatural to use at first. Even still, it is important to use Image and not img, as the Next.js variant provides additional benefits, such as being responsive by default, a priority prop, ability to set a placeholder image during loading, as well as other image optimizations. ","date":"2024-11-20","objectID":"/nextjs-for-react-devs/:2:0","tags":["Next.js","React"],"title":"Next.js for React Devs","uri":"/nextjs-for-react-devs/"},{"categories":null,"content":"Hosting Your Next.js App One of my favorite ways to host React apps has been through Cloudflare Pages. I enjoy how simple this method is with linking my GitHub account to Cloudflare for automatic deployments as well as using Cloudflare for purchasing and setting up custom domain names. Given this, I decided to host my first Next.js app through Cloudflare pages. I began following the Cloudflare docs and eventually got the site deployed and “working”, after adding export const runtime = \"edge\"; to the top of every file. While I was able to successfully deploy the website, Next.js currently only supports the “Edge” runtime. Next.js has two server runtimes available: Node.js (default) and Edge. The Node.js runtime has access to all Native Node.js APIs, while the Edge runtime contains a more limited set of APIs. This was a problem, as I was unable to use some packages, such as plaiceholder. It seemed like there were also other issues, such as with the Next.js \u003cImage/\u003e component optimizations and caching. Therefore, I switched to Vercel to host my website. Vercel worked great, and I was easily able to get everything up and running utilizing the latest Next.js features and optimizations. However, this soft “vendor lock” currently seems like one of the biggest downsides to using Next.js. To get the best experience, using Vercel currently feels required, and I image self-hosting a Next.js app would be even more challenging/limiting. That said, I expect better support for Next.js app hosting in the future, as well as more framework competition as products like Remix begin supporting all the latest React features. ","date":"2024-11-20","objectID":"/nextjs-for-react-devs/:3:0","tags":["Next.js","React"],"title":"Next.js for React Devs","uri":"/nextjs-for-react-devs/"},{"categories":null,"content":"Next.js: the Future of React Overall, I have been very impressed with Next.js. While it is quite opinionated about certain things (Image component, App router, etc.), the benefits are clear. Specifically, the App router is amazing, and I love using the folder and file naming conventions for pages. Given that the future of React is frameworks, I think that Next.js is well positioned to be the leading player. ","date":"2024-11-20","objectID":"/nextjs-for-react-devs/:4:0","tags":["Next.js","React"],"title":"Next.js for React Devs","uri":"/nextjs-for-react-devs/"},{"categories":null,"content":"Recently, upon migrating Lali Solari’s personal website from vanilla React to Next.js (see this Contentful blog post for a great guide on getting started with Next.js App Router and Contentful), I decided to try out the Contentful GrapQL API. In the past, I have always used the Contentful Javascript SDK, which is a great tool for interacting with the Contentful REST API. However, I wanted to use the native web fetch API to take advantage of specific Next.js features, such as caching, so I decided to give the GraphQL API a try. Thanks to the GraphiQL browser tool and the ability to only get back the data that I need, I found the Contentful GraphQL API experience even better than working with the Contentful Javascript SDK. ","date":"2024-10-03","objectID":"/graphql-a-breathof-fresh-air/:0:0","tags":["GraphQL","REST"],"title":"GraphQL: a Breath of Fresh Air","uri":"/graphql-a-breathof-fresh-air/"},{"categories":null,"content":"GraphiQL as TDD? GraphiQL is an incredible browser based development tool. It allows you to write queries and mutations, with auto-completion, in the browser before even writing a single line of code. Contentful’s GraphQL API supplies the GraphiQL tool environment, which can be reached at https://graphql.contentful.com/content/v1/spaces/SPACE_ID/explore?access_token=YOUR_ACCESS_TOKEN. Using the in-browser text editor, I was able to quickly write queries to get the data that I needed, and then test them in the browser. While this is not a replacement for tests in the codebase, it is a great way to see what the return data will look like, before writing any code. But furthermore, this is not wasted effort, as the queries that you write in GraphiQL can be copied and pasted directly into your codebase. Here is what one of my GraphiQL queries looked like: GraphiQL Query Copying this directly into my codebase, I get the following. const MANIFESTO_PAGE_QUERY = ` query ($locale: String!) { manifiestoCollection(locale: $locale) { items { title description mediaCollection { items { title url } } } } } `; ","date":"2024-10-03","objectID":"/graphql-a-breathof-fresh-air/:1:0","tags":["GraphQL","REST"],"title":"GraphQL: a Breath of Fresh Air","uri":"/graphql-a-breathof-fresh-air/"},{"categories":null,"content":"Exactly the Data Needed My other favorite thing about using the Contentful GraphQL API was the ability to get only the data I needed, with minimal boilerplate code. For reference, here is what the call to get the Manifesto page data was in the original React project, using the Contentful SDK: const client = getClient(); const res = await client.getEntries\u003cManifesto\u003e({ content_type: \"manifiesto\", locale: languageMode, }); where Manifesto was export interface Manifesto { title: string; description: string; media: Photo[]; } export interface Photo { fields: { description: string; file: { contentType: string; details: { image: { width: number; height: number; }; size: number; }; fileName: string; url: string; }; title: string; }; sys: { id: string; }; } As you can see, these are very verbose types that I needed to define myself based on the response from the REST API call via client.getEntries\u003cManifesto\u003e. While I still need to define the response type myself when using the GraphQL API, it is much simpler given that the Photo array is now just a mediaCollection on which I can simply grab the title and url (both of which are strings). This not only simplifies the return type, but also reduces the amount of response code returned via the API call. ","date":"2024-10-03","objectID":"/graphql-a-breathof-fresh-air/:2:0","tags":["GraphQL","REST"],"title":"GraphQL: a Breath of Fresh Air","uri":"/graphql-a-breathof-fresh-air/"},{"categories":null,"content":"Potential GraphQL Drawbacks The only complaint that I had with using the Contentful GraphQL API versus the REST API is needing to manually create the fetch call. Here is what that ended up looking like for me: const res = await fetch( `https://graphql.contentful.com/content/v1/spaces/${process.env.CONTENTFUL_SPACE_ID}/environments/${process.env.CONTENTFUL_ENVIRONMENT_ID}`, { method: \"POST\", headers: { \"Content-Type\": \"application/json\", Authorization: `Bearer ${process.env.CONTENTFUL_CONTENT_DELIVERY_API_ACCESS_TOKEN}`, }, body: JSON.stringify({ query, variables }), next: { tags: [\"portfolioContent\"] }, } ); However, in my case this was required in order to take advantage of the Next.js enhanced fetch API (see the next tag above that facilitates caching). Moreover, this logic only needs to be written once and can then be encapsulated in a function to be used with multiple queries. ","date":"2024-10-03","objectID":"/graphql-a-breathof-fresh-air/:3:0","tags":["GraphQL","REST"],"title":"GraphQL: a Breath of Fresh Air","uri":"/graphql-a-breathof-fresh-air/"},{"categories":null,"content":"Don’t Default to REST Because I was familiar with the Contentful Javascript SDK and that way of querying data, I had simply defaulted to this in my new project. Even though I have used GraphQL before, I was stuck in a RESTful, traditional API mindset. But given the ability to get exactly the data that is need and the excellent developer tools of GraphiQL and associated type completion, I am very glad I tried out using GraphQL again. I hope you also consider using GraphQL in the future! ","date":"2024-10-03","objectID":"/graphql-a-breathof-fresh-air/:4:0","tags":["GraphQL","REST"],"title":"GraphQL: a Breath of Fresh Air","uri":"/graphql-a-breathof-fresh-air/"},{"categories":null,"content":"I recently found myself needing to lift some parts of my application state into the URL. I usually default to use some state management solution in my web projects, and I am a huge fan of Zustand. However, there comes a time when using this type of state management alone may not provide all the desired functionality. ","date":"2024-06-27","objectID":"/benefits-of-lifting-state-to-the-url/:0:0","tags":["State Management"],"title":"Benefits of Lifting State to the URL","uri":"/benefits-of-lifting-state-to-the-url/"},{"categories":null,"content":"Why Lift State Normally, when using something like Redux, the global store lives in memory within the JavaScript runtime of your application. This generally would work great, but what if a user wanted to share part of their application state with another user running the application on another computer? Or what if the same user simply wanted to share some application state between different tabs in the same browser? If all your state is stored in runtime memory, this isn’t possible. The solution: put the part of the state that you want to share between instances into the URL. For example, on the PhotoVoice Japan website, I wanted users to easily be able to share voices. Initially, a user would have to go to the “search” tab, explain what search params to use and then also share the title of the voice that they wanted the other user to view. But after lifting the voice ID (in my case I am using Contentful’s internal Entry ID, but this can be any unique identifier) into the URL, they need only share a single URL to link directly to a specific voice. For example: https://photovoicejapan.com/display/23z0n4kUPKvV0KYDbwTtAz. This change not only added a new feature in being able to share specific voices, but also simplified the existing Zustand store, by removing the concept of a “currentVoice” and simply having that “currentVoice” entry ID live in the URL. Furthermore, I find having this part of the state in the URL can aid in debugging, since “reproducing” state is much easier by simply sharing a URL, instead of needing to click through multiple UI windows/modals. ","date":"2024-06-27","objectID":"/benefits-of-lifting-state-to-the-url/:1:0","tags":["State Management"],"title":"Benefits of Lifting State to the URL","uri":"/benefits-of-lifting-state-to-the-url/"},{"categories":null,"content":"Time to Put Everything in the URL? Given the clear benefits of lifting state to the URL, why not just move everything there? For some things, it probably just isn’t important enough to move to the URL or serves no real purpose. For example, the user’s light/dark mode preference. This can just live in memory and default to the user’s browser preference. If it’s very important that this preference is saved, it can be linked somehow to a concept of a user and their “profile.” Additionally, some pieces of state do not make sense to share. For instance, maybe the user is in the middle of entering data or making selections in a multi-step modal. It is likely that such a workflow would be all or nothing, and it is therefore unnecessary to store the intermediate parts of state in the URL. ","date":"2024-06-27","objectID":"/benefits-of-lifting-state-to-the-url/:2:0","tags":["State Management"],"title":"Benefits of Lifting State to the URL","uri":"/benefits-of-lifting-state-to-the-url/"},{"categories":null,"content":"Enjoying the Benefits Multilocation State Lifting state to the URL is helpful when needing to easily share state between users or instances and to aid in state reproduction for debugging and troubleshooting purposes. Utilizing both runtime memory and the URL to manage state is important as applications become more complex. I hope you find that lifting state to the URL can also help improve the functionality of your applications! ","date":"2024-06-27","objectID":"/benefits-of-lifting-state-to-the-url/:3:0","tags":["State Management"],"title":"Benefits of Lifting State to the URL","uri":"/benefits-of-lifting-state-to-the-url/"},{"categories":null,"content":"Recently, I completed a large data migration on the PhotoVoice Japan website. The purpose of this migration was to clean up existing content models and utilize Contentful’s locales feature to allow for cleaner and more efficient multi-language support. Thanks to Contentful’s use of multiple Environments within a project Space, this migration was quite straightforward. ","date":"2024-05-11","objectID":"/streamlining-data-migrations-in-contentful/:0:0","tags":["Contentful"],"title":"Streamlining Data Migrations in Contentful","uri":"/streamlining-data-migrations-in-contentful/"},{"categories":null,"content":"Cloning your Existing Environment Fortunately, Contentful offers a very generous free “Intro” space license. Under the Intro license we are allowed three environments. Contentful Space Licenses Having access to these multiple environments is what allows us to make a seamless data migration. In your current space you should already have one environment, something like “master”. To add a new environment, go to “Settings” in the top right corner and then select “Environments” from the dropdown. Next click “Add environment”. This should open a popup which asks you to name the new environment and also asks where you want to copy the new environments data from: Contentful Add Environment Cloning from the current environment gives us an exact copy of our existing data that we are free to modify without affecting the original environment. This means you will have new copies of both your entries and content types in the new environment. After adding the new environment, you can access it by clicking on your space name in the top left corner and selecting it: Contentful Environment Selection ","date":"2024-05-11","objectID":"/streamlining-data-migrations-in-contentful/:1:0","tags":["Contentful"],"title":"Streamlining Data Migrations in Contentful","uri":"/streamlining-data-migrations-in-contentful/"},{"categories":null,"content":"Perform the Data Migration Now that we have a new “v2” environment, we can make whatever changes we want to the content models. In my case, this involved cleaning up some fields on various content models and adding a new locale. Contentful’s free plan also allows you to utilize up to two locales. This feature can be accessed via “Settings” then selecting “Locales” from the dropdown menu. After adding the new locale and fixing the affected entries, we are ready to point our code to the new data. ","date":"2024-05-11","objectID":"/streamlining-data-migrations-in-contentful/:2:0","tags":["Contentful"],"title":"Streamlining Data Migrations in Contentful","uri":"/streamlining-data-migrations-in-contentful/"},{"categories":null,"content":"Pointing Production to the New Environment In order to get your code working with the new environment, we will need to update a few secrets as well as change some API token settings in the Contentful dashboard. First, go to “Settings” then “API keys” in the Contentful dashboard. Here, you may either create a new API key or provide your current development access token with access to the new environment. For my use case, I opted for the latter. In the specific access token settings, you will simply want to scroll down to the bottom and make sure both environments are enabled: Contentful API Key Environment Selection On the code side of things, you will need to update your “environment” value from “master” to “v2”. Assuming this value is not hard-coded, you will also want to make sure you update the environment string in your deployment pipelines. Once your API key has been updated with the new permissions and your code has been changed to point to the new environment, you should start seeing your site utilizing your “v2” entries and content models. ","date":"2024-05-11","objectID":"/streamlining-data-migrations-in-contentful/:3:0","tags":["Contentful"],"title":"Streamlining Data Migrations in Contentful","uri":"/streamlining-data-migrations-in-contentful/"},{"categories":null,"content":"Take Advantage of Contentful Environments Contentful environments are a powerful tool to update existing entries and content models without having to worry about affecting production data. Additionally, they allow you to keep around older versions of the data for future reference or revisions. Given that Contentful’s free plan also allows usage of up to three environments, there is no reason not to take advantage of this feature. Hopefully utilizing multiple Contentful environments will allow you to update the content on your site with confidence! ","date":"2024-05-11","objectID":"/streamlining-data-migrations-in-contentful/:4:0","tags":["Contentful"],"title":"Streamlining Data Migrations in Contentful","uri":"/streamlining-data-migrations-in-contentful/"}]